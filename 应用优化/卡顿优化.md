# 画面渲染
## 显示原理
屏幕的显示，是受控于两种信号[[VSync]]、[[HSync]]

![[7b29e97c3c344296b64dc654ae14244b~tplv-k3u1fbpfcp-zoom-1.image.png|500]]
我们可以把屏幕想象成刷墙师傅，每一帧的数据就是桶里的油漆，而GPU就是负责提供油漆的店老板。

## 屏幕撕裂问题
在屏幕显示图形图像的过程中，是不断从帧缓存区获取一帧一帧数据进行显示的，然后在渲染的过程中，帧缓存区中仍是旧的数据，屏幕拿到旧的数据去进行显示，在旧的数据没有读取完时 ，新的一帧数据处理好了，放入了缓存区，这时就会导致屏幕另一部分的显示是获取的新数据，从而导致屏幕上呈现图片不匹配，人物、景象等错位显示的情况。
![[78132.jpg.png|300]]
苹果官方针对屏幕撕裂问题，目前一直使用的方案是[[垂直同步]]+[[双缓存区]]，可以从根本上防止和解决屏幕撕裂。

## 掉帧问题
假如App阶段和Render server阶段耗时过长，导致从缓存区获取位图显示时，下一帧的数据还没有准备好，获取的仍是上一帧的数据，
![[Pasted image 20211013191614.png|600]]


## iOS 渲染循环
![[62649.jpg.png|600]]
`渲染循环`是一个`连续性`的过程。通过触碰事件传送给app，然后转化到用户界面，向操作系统传送。最终呈现给用户，这就是循环，随着设备的刷新率发生。

在`iphone和ipad`中，`VSYNC`信号的频率为`60HZ`，在 `ipad pro`中为 `120HZ`。我们以iphone为例，这意味着每 `16.67`毫秒，就可以显示一个`新帧`。

整个`渲染循环`由`五个阶段`组成 ：`事件阶段(Event)`、`提交阶段`、`渲染准备`、`渲染执行`、`展示阶段`。


![[Pasted image 20211013191914.png|600]]

### 事件阶段
![[75022.jpg.png|600]]
App处理`触碰事件`或者`Timer`等其他事件，决定用户界面是否需要变化。


### 提交阶段
![[15363.jpg.png|600]]
app向渲染服务器提交渲染命令

### 渲染阶段
![[99954.jpg.png|600]]
#### 渲染准备
在下一个[[VSync]]中，渲染服务器处理命令，在渲染准备阶段，为在GPU上绘制做好准备
#### 渲染执行
在渲染执行阶段，GPU将用户界面的最后图像绘制出来。

### 展示阶段
![[16772.jpg.png|600]]
在下一个[[VSync]]，这一帧将会呈现给用户。


# 卡顿原因

# 卡顿优化

# 检测

# 1. 卡顿优化
## 了解CPU和GPU
在屏幕成像过程中，CPU和GPU的作用是至关重要的。

* **CPU**
- Central Processing Unit，中央处理器，在iOS程序中，负责对象的创建和销毁、对象属性的调整、布局的计算、文本的计算和排版规格、图片的格式转码和解码、图像的绘制（**Core Graphic**）
* **GPU** 
- Graphics Processing Unit，图形处理器，负责纹理的渲染。如果没有接触过OpenGL的朋友，可能不太好理解纹理渲染这个概念，我们知道，屏幕上面的物理元件是像素，我们在屏幕上面看到的图片，文字，视频，就是由屏幕上的所有像素，通过控制色值变化而呈现出来的。那么像素的色值数据，就是由GPU计算得出的，然后将这些数据提交给视频控制器，由它负责显示到屏幕上。

![[dfbcc46f8d564984b762349e40995506~tplv-k3u1fbpfcp-zoom-1.image.png]]

iOS中采用的是双缓冲机制，分为前帧缓存和后帧缓存。



## 卡顿产生的原因
我们手机屏幕的刷帧率是60FPS（**Frame per Second** 帧/秒），也就是会所1秒钟的时间，屏幕可以刷新60帧（次）。完成一帧刷新的用时是16.6毫秒。因此垂直同步信号**VSync**就是每16.6毫秒发出一次。

两次**VSync**之间的这16.6毫秒，就是被CPU和GPU共同完成下一帧画面的计算和渲染工作的时间。但是CPU计算和GPU渲染所用的时间是取决于任务的运算量的，因此就有可能大于16.6毫秒，也有可能小于或者等于16.6毫秒。

这里我们假设Tc=CPU计算时间，Tg=GPU渲染时间。如果Tc+Tg <= 16.6ms，那么完美，下一帧画面的数据可以在**VSync**到来之间就准备好；但是如果Tc+Tg > 16.6ms，意味着屏幕将要开始显示下一帧画面了，但是CPU和GPU那里却还在咔咔咔的准备着画面数据，那么没办法，在接下来的**16.6ms**周期里面，屏幕就继续用上一帧的画面数据来显示。同一个画面被显示了过长的时间，就造成了视觉上可感知到的卡顿现象。再通过下图来体会一下
![[8fffc98e674c4da59bc9e67f7cd30473~tplv-k3u1fbpfcp-zoom-1.image.png]]

上看我们了解了产生的原因，就是由于CPU计算时间和GPU的渲染时间过长导致的。因此想要优化卡顿问题，无非就是从CPU和GPU下手，减轻它们的工作量，以控制它们的操作耗时。

## 卡顿优化-CPU
首先开看看CPU，我们有如下途径来减轻它的计算任务

尽量用轻量级的对象，比如简单的数字，尽量选择基础数据类型，不要使用NSNumber，对象操作的开销肯定大于基础数据类型的开销。

CALayer是用来显示图像的，UIView是负责处理触摸交互事件的，UIView内部封装了CALayer属性，因此UIView的图像显示实际上是它内部的这个CALayer来完成的。因此如果我们不需要考虑触摸事件，只是单纯的要显示内容的话，可以考虑用CALayer取代UIView。

尽量提前计算好布局，在有需要的时候一次性调整对应属性，不要多次修改图片的size最好是跟UIImageView的size刚好一致，可以省去图片剪裁的操作开销控制一下线程的最大并发数

尽量把耗时操作放到子线程处理（比如文本的尺寸计算、绘制，图片的解码、绘制）

## 卡顿优化-GPU
对与GPU，有下列方案可以减少渲染开销
* 尽量避免段时间内大量的图片显示，尽可能将多张图片合成一张图片显示，比如说三张图片同时显示，不如将这三张图片合成到一块作为一张图片来显示

* GPU能处理的最大纹理尺寸是4096*4096，一旦超过这个尺寸，就会占用CPU资源进行处理，这样势必影响CPU的运算效率，因此纹理尽量不要超过这个尺寸

* 尽量减少视图的数量和层级

* 减少不必要的透明的视图

* 尽量避免离屏渲染

### 离屏渲染
在OpenGL中，GPU有两种渲染方式
* **On-Screen Rendering**：当前屏幕渲染，在当前用于显示的屏幕缓冲区进行渲染操作
* **Off-Screen Rendering**：离屏渲染，在当前屏幕缓冲区以外开辟一个新的缓冲区进行渲染操作

为什么离屏渲染消耗性能？
* 需要创建新的缓冲区
* 离屏渲染的整个过程中，需要多次切换上下文环境，先是从当前屏幕缓冲区（**On-Screen**）切换到离屏缓冲区(**Off-Screen**)，等完成离屏渲染操作之后，将离屏缓冲区的渲染结果显示到屏幕上，然后还需要将上下文环境从离屏缓冲区切换回当前屏幕缓冲区。

哪些操作会触发离屏渲染？
* 光栅化操作 layer.shouldRasterize = YES
* 遮罩设置 layer.mask
* 圆角设置 layer.masksToBounds = YES&layer.cornerRadius>0
🥝可以考虑通过CoreGraphics绘制剪裁圆角，或者叫美工提供圆角图片🥝
* 阴影设置 layer.shadowXXX
🥝如果设置了layer.shadowPath就不会产生离屏渲染🥝

## 卡顿检测
平时我们所碰到的卡顿，主要是在主线程执行了比较耗时的操作，可以在主线程**RunLoop**中添加observer，通过监听**RunLoop**的状态切换耗时，来监控卡顿。



### 4.2 界面优化
### 4.2.1 卡顿的原理
掉帧
[image:0F2CF84B-A33E-4CC4-8F55-FE4F93D77C59-439-0000240F72C53819/22763d55f4c1486094d7289953389dd8~tplv-k3u1fbpfcp-watermark.image.png]
![[22763d55f4c1486094d7289953389dd8~tplv-k3u1fbpfcp-watermark.image.png]]

### 4.2.2 界面流畅度的评测
**界面优化建议(后面我会单独写一篇专门讲解界面优化)**
耗时操作，不要放在主线程
合理使用CPU与GPU
复制代码
CPU: 计算显示内容， 比如视图的创建、布局计算、图片解码、文本绘制. 这些一般都是uikit的问题,苹果是用autolayout布局的， GPU :会把CPU计算好的数据进行渲染，视图+数据+帧率 = 很多图片
[摘自]  [www.javashuo.com/article/p-y…](http://www.javashuo.com/article/p-yjmjlubo-bz.html) 
**4.2.2.1 Color Blended Layers (图层混合)**
设置opaque 属性为true。 所有控件默认都为true可以忽略 给View设置一个不透明的颜色，没有特殊须要设置白色便可。 尤其是label.backgroudColor
label.backgroundColor = [UIColor whiteColor];
label.layer.masksToBounds = YES;
复制代码
到这里你可能奇怪，设置label的背景色第一行不就够了么，为何还有第二行？这是由于若是label的内容是中文，label实际渲染区域要大于label的size，最外层多了一个sublayer，若是不设置第二行label的边缘外层灰出现图层混合的红色，所以须要在label内容是中文的状况下加第二句。单独使用label.layer.masksToBounds = YES是不会发生离屏渲染。 注意点：UIImageView控件比较特殊，不只须要自身这个容器是不透明的，而且imageView包含的内容图片也必须是不透明的，若是你本身的图片出现了图层混合红色，先检查是否是本身的代码有问题，若是确认代码没问题，就是图片自身的问题
**4.2.2.2 光栅化**
适用状况：通常在图像内容不变的状况下才使用光栅化，例如设置阴影耗费资源比较多的静态内容，若是使用光栅化对性能的提高有必定帮助。 非适用状况：若是内容会常常变更,这个时候不要开启,不然会形成性能的浪费。 例如咱们在使用tableViewCell中，通常不要用光栅化，由于tableViewCell的绘制很是频繁，内容在不断的变化，若是使用了光栅化，会形成大量的离屏渲染下降性能。
**4.2.2.3 Offscreen rendering (圆角)**
阴影绘制shadow:使用ShadowPath来替代shadowOffset等属性的设置 imageViewLayer.shadowPath = CGPathCreateWithRect(imageRect, NULL); 利用GraphicsContex生成一张带圆角的图片或者view，这里不写具体实现过程，须要的能够度娘Copy，不少现成的代码。
### 4.3卡顿检测:
FPS 50-60帧是非常流畅的，低于高于都不正常。YYFPSLabel
```objc
//YYLabel YYDemo
YYFPSLabel *_fpsLabel = [YYFPSLabel new];
[_fpsLabel sizeToFit];
_fpsLabel.bottom = KScreenHeight - 55;
_fpsLabel.right = KScreenWidth - 10;
//    _fpsLabel.alpha = 0;
[kAppWindow addSubview:_fpsLabel];

```
如果界面比较复杂的，建议使用AsyncDisplayKit做控件绘制，而不是苹果自带的autolayout。
