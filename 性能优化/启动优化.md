启动优化
**App启动过程分析**
**App的启动可以分为两种**
* 冷启动：从零开始启动App
* 热启动：App已经在内存中，处在后台状态中，在次点击图标启动App
App的启动时间优化，主要是针对冷启动来进行优化的。那么首先我们就需要了解一下App的冷启动过程包含哪些步骤。
* （一）dyld阶段：dyld1dynamic link editor），Apple的动态链接器，可用来加载Mach-O文件（可执行文件、动态库等等）。冷启动一个app之后，首先是dyld开始工作，它负责两件事情：
	1. 加载App的可执行文件，同时会递归加载所有依赖库的动态库。
	2. 当完成可执行文件和动态库的加载之后，就通知Runtime进行下一步处理。
* （二）Runtime阶段：在这个阶段，Runtime做了如下的工作：
	1. 调用map_images函数对可执行文件的内容进行解析和处理。
	2. 在load_images函数中调用call_load_methods，以调用所有Class和Category的+load方法。
	3. 进行各种**objc**结构的初始化（例如**objc**类的注册，初始化类对象等等）
	4. 调用C++静态初始化器以及被_attribute_((constructor))修饰的函数
**到此为止，可执行文件和动态库中的所有所有**Symbols**（符号，包括 Class， Protocol， Selector， IMP等等）都已经按照规定格式加载到内存中，并且被runtime所管理**
* （三）main函数阶段
**小结**
* App的冷启动由dyld主导，将可执行文件加载到内存，顺便把所依赖的动态库也加载到内存，然后通知runtime进行相应处理
* runtime负责将上面的内容初始化成`**bjc**定义的结构体
* 最后当初始化工作完成后，dyld就会调用main函数。接下来便是main函数—>UIApplicationMain函数 —>didFinishLaunchingWithOptions方法。

[image:87831463-6DB7-4C69-8640-9154D0F08931-439-000023FE321A84E3/186f338fadad480ab914effa5971d13b~tplv-k3u1fbpfcp-zoom-1.image.png]
![[186f338fadad480ab914effa5971d13b~tplv-k3u1fbpfcp-zoom-1.image.png]]

**App启动优化**
**dyld阶段优化**
* 减少动态库，合并一些动态库，定期清理不必要的动态库
* 减少Objc类、Category的数量，减少Selector数量，定期清理不再需要的Class和Category
* 减少C++虚函数的数量，因为虚函数会导致额外的虚表的存在
* 如果是**Swift**尽量使用struct
**Runtime阶段优化**
* 用+initialize方法+dispatch_once的组合来取代所有的 _attribute_((constructor))、C++静态构造器、Objc的+load方法。
**main阶段优化**
在不影响用户体验的前提下，尽可能讲一些操作延迟，不要全都放在didFinishLaunchingWithOptions 方法中。 ###（四）安装包瘦身 iOS的安装包（ipa）主要有可执行文件和资源组成 **可执行文件**——就是由我们iOS项目的代码经过编译连接产生的二进制文件，要想对可执行文件进行瘦身，有如下几种思路：
* 编译器优化
Strip Linked Product、Make Strings Read-Only、Symbols Hidden by Default设置为YES 去掉异常支持，Enable C++ Exceptions、Enable Objective-C Exceptions设置为NO，Other C Flags添加-fno-exceptions
* 通过第三方工具 [AppCode](https://www.jetbrains.com/objc/) 检测项目中用不到的代码：菜单 —> **Code** —> **Inspect Code**
**资源**——包括我们iOS项目中的图片、音频、视频、**storyboard**等，对其进行优化的思路有
* 对资源进行无损压缩
* 去除没有用到的资源（ [第三方检测工具](https://github.com/tinymind/LSUnusedResources) ）